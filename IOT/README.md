# ITEC411001 사물컴퓨팅이론및실습 / 2019년 2학기 / 강순주

>  운영체제 과목의 후수과목인 사물컴퓨팅 이론 및 실습을 수강하며 수행한 과제들 입니다.
<br>Eclips IDE에서 C언어로 코드를 작성하였고,
<br>이를 RTlab의 실시간운영체제(UBINOS)와 MCU에서 구동하였습니다.

## 요약

> HW1 : Memory overflow의 발생<br>HW2 : Calibration(color, distance)
<br>HW3 : 우선순위 스케쥴링<br>HW4 : Semaphore<br>HW5 : Timer를 이용한 Stopwatch 구현 

## 수행내용
### 1. HW1 : Memory overflow의 발생
#### 개요
> 교차개발환경에 대한 코드를 짜고 디버깅해본다. <br>그 예시로 ESTK 모바일 보드의 메모리공간을 다뤄보면서 인위적으로 메모리 overflow를 발생시켜본다.

#### 다이어그램/구조
![](https://github.com/hwa10209/IOT/blob/master/img/1_1.PNG)
> 2주차 실습이 끝난 소스파일을 기준으로 코딩하여 lib_new_estk_api 를 포함한 기존의 라이브러리와 lib_new 라이브러리가 include 되어 있습니다.	
```
int usrmain(int argc, char * argv[])
```
> ESTK 의 작업을 실행, 디버깅을 시작할 때 가장 먼저 실행되는 함수이다.
<br>rootfunc task를 확인하고 ‘ubik_comp_start();’를 이용하여 실행한다.

```
static void rootfunc(void * arg)
```
> ESTK 보드의 lcd를 활성화하고 아래에 언급될 함수에서 할당할 메모리의 크기를 확인할 변수를 지정, 그 함수를 반복적으로 호출하면서 수를 센다.

```
void myallocation(int count)
```
> 한번 호출될 때 마다 malloc 함수를 이용하여 1KB씩 동적할당을 시도한다. 
<br>만약 메모리 할당이 성공한다면 넘겨받은 count를 이용하여 성공적으로 할당된 메모리의 크기를 lcd에 출력한다.<br>
그러나 공간이 부족하여 실패했을 경우 실패했다는 메시지를 띄운다. 
#### 실행결과
![](https://github.com/hwa10209/IOT/blob/master/img/1_2.PNG)

> 디버그를 시작하자 짧은 텀을 두고 한줄씩 메모리 할당이 성공되었다는 메시지가 출력되면서 실제로 1KB 크기의 메모리가 할당된다.
<br>조금 기다리다가 121KB 지점까지는 성공적으로 할앙이 되고 그 뒤로부터는 할당에 실패하게 되고 overflow가 발생했다는 메시지를 출력해준다.
<br>이 때부터는 조금 더 긴 텀을 두고 메모리 할당을 계속하는데 여전히 overflow가 발생함을 알 수 있다. 

#### 고찰
>먼저 위의 과정을 통해 디버거를 이용하여 ESTK 보드의 명령어를 한줄 한줄 실행하면서 메모리를 할당하고 메모리가 가득차면 더 이상 할당을 할 수 없는 일련의 과정이 컴퓨터의 그것과 거의 같음을 알 수 있었다.  물론 그 과정이 순탄하지는 않았다. 처음 시도해 보았을 때 overflow를 빨리 일으키기 위해 10KB씩 malloc 함수를 실행하였다. 교재를 참고하여 128KB 의 메모리가 있다는 것을 확인했고 12번 내외의 실행끝에 오류가 나서 멈추리라 생각했으나 예상과 다르게 1000,2000KB 가 할당되어도 멈추지 않았다. 코드를 검토하던 도중 malloc의 메모리 할당이 실패했을 경우 어떤 작업을 할지 지정하지 않았다는 것을 확인했고 실패했을 때의 동작을 추가한 뒤 1KB씩 할당해 보았다. 그제서야 내가 예상했던 값과 비슷한 121KB 이후에서 overflow가 발생하였다. 7KB 정도는 메모리 할당함수가 아닌 다른 함수들을 실행하면서 사용된 것 같다.
<br>위의 실행에서 오류가 났다고 해서 동작이 멈추거나 디버깅이 종료되지는 않았고 내가 오류를 예상하고 다루자 비로소 그 확인을 할 수 있었는데 만약 이것이 시중에 나와있는 제품이었다면 의도치 않은 동작을 하여 사고가 났을 수 도 있을 것이다. 이를 바탕으로 코드를 짤 때 메모리구조와 크기, 메모리를 다루는 방법을 충분히 고려해야 한다는 것을 깨달았다.  다음에 있을 실험들에서 메모리가 overflow 되지 않는 범위를 고려하여 한정된 메모리가 낭비되지 않도록 효율적인 코드를 짜야 할 것이다. 또 PC와 다르게 정해진 동작만을 수행하기 위해서는 128KB가 부족한 것은 아니라고 생각하지만 만약 위의 경우와 같이 실행은 잘 되지만 의도치 않은 동작이 발생할 때 메모리가 overflow가 발생한 것은 아닌지 의심해 보아야겠다.

---

### 2. HW2 : Calibration(color, distance)
#### 개요
> 레고 EV3_sensor(광센서)와 레고 NXT_sensor(초음파 센서)를 이용하여 외부 환경 값을 받을 때 작업이 수행되는 환경마다 달라질 수 있는 값들에 대한 calibration을 수행 후 센서 값에 따라 모터의 회전 속도가 달라지게 해본다. 
#### 다이어그램/구조
* 광센서로 모터 제어하기
![](https://github.com/hwa10209/IOT/blob/master/img/2_1.PNG)
> 3주차 실습이 끝난 소스파일을 기준으로 코딩하여 lib_new_estk_api ,lib_new를 포함한 기존의 라이브러리와 sensor, sensorcalib, switch, EV3_sensor, motor_driver 라이브러리가 include 되어있습니다.
```
int usrmain(int argc, char * argv[])
```
> ESTK 의 작업을 실행, 디버깅을 시작할 때 가장 먼저 실행되는 함수이다.
<br>rootfunc task를 확인하고 ‘ubik_comp_start();’를 이용하여 실행한다.

```
static void rootfunc(void * arg)	
```
> ESTK 보드의 lcd,motor,encoder 활성화, ev3_seosor 활성화 및 컬러모드 설정, 센서의 calibration을 위해 추가로 rootfunc 바로 위에서 MAX_COLOR_LEVEL, color_value를 define
<br>define 한 값을 이용하여 sensorcalib 라이브러리의 calibEV3Sensor 함수를 호출하여 총 8가지 색깔에 대해서 광센서의 calibration을 수행한다.
<br>아래에 설명될 scan함수와 rotate 함수를 반복적으로 호출하며 작업을 수행. <br>아래 함수들의 실행시간에 의해 50msec 정도에 한번씩 반복된다.

```
int scan()
```
> sensorcalib 라이브러리의 getlevel함수와 EV3_sensor 라이브러리의 ev3_sensor_get 함수를 이용하여 색을 인식하고 level값을 판별한다.
<br>판별한 level 값을 바탕으로 값을 lcd에 출력하고, return 해준다. 값을 직관적으로 구분할 수 있도록 EV3_sensor.h 에 정의된 이름들을 이용한다.

```
void rotate(int level)
```
> 판별된 level 값에 비례하도록 모터의 회전속도를 지정해준다, 색깔이 없다면 회전하지 않는다.
<br>50msec의 delay를 두어 전체적인 과정의 한번의 수행(광센서 센싱)의 주기를 지정.

* 초음파센서로 모터 제어하기
![image](https://user-images.githubusercontent.com/74942951/100364093-fae0aa80-3040-11eb-9472-566fee2899f7.png)

```
int usrmain(int argc, char * argv[])
```
> ESTK 의 작업을 실행, 디버깅을 시작할 때 가장 먼저 실행되는 함수이다.<br>rootfunc task를 확인하고 ‘ubik_comp_start();’를 이용하여 실행한다.

```
static void rootfunc(void * arg)
```
> ESTK 보드의 lcd,motor,encoder 활성화, 초음파센서 활성화
<br>센서의 calibration을 위해 추가로 rootfunc 바로 위에서 MAX_DIS_LEVEL, distance_value를 define
<br>define 한 값을 이용하여 sensorcalib 라이브러리의 calibSensor 함수를 호출하여 총 5가지 거리에 대해서 광센서의 calibration을 수행한다.
<br>아래에 설명될 scan함수와 rotate 함수를 반복적으로 호출하며 작업을 수행.<br>아래 	함수들의 실행시간에 의해 50msec 정도에 한번씩 반복된다.

```
int scan()
```
> sensorcalib 라이브러리의 getlevel함수와 sensor 라이브러리의 sensor_get 함수를 이용하여 거리를 인식하고 level값을 판별한다.
<br>판별한 level 값을 바탕으로 값을 lcd에 출력하고, return 해준다. 

```
void rotate(int level)
```
> 판별된 level 값에 비례하도록 모터의 회전속도를 지정해준다, 멀리 있을수록 빨라지고 5cm 보다 가까이 있다면 회전하지 않는다.	
<br>50msec의 delay를 두어 전체적인 과정이 한번 수행(광센서 센싱)되는 주기를 지정.

#### 실행결과
* 광센서로 모터 제어하기 - 색 구분
![](https://github.com/hwa10209/IOT/blob/master/img/2_2.PNG)

![](https://github.com/hwa10209/IOT/blob/master/img/2_3.PNG)

![](https://github.com/hwa10209/IOT/blob/master/img/2_4.PNG)

![동작 영상](https://youtu.be/N5liBLh55U0)

> 시작하면서 실습 시간에 했던 것과 같이 calibration을 시작한다. 이번에는 색깔모드를 사용하여 광센서에서도 알록달록한 빛을 내보낸다. 각각 무광,검,파,녹,노,빨,흰,갈색 여덟 개의 순서대로 0번부터 7번까지 값을 정해주는 calibration을 완료한다. 그 후 색을 순서대로 비춰보면 뒤쪽에 나오는 색일수록 모터 회전 속도가 점점 빨라지게 해 두었다. 허공을 비추면 색이 없는 것으로 간주하고 모터속도가 0(멈춤)이 된다. calibration 하는 과정에선 매끈하게 잘 되었으나 광센서를 그 색에 가져다 대었을 때 순간적으로 색을 잘못 읽는 경우가 가끔씩 있어서 모터속도가 매끄럽게 증가하지 않고 뚝뚝 끊기는 경향이 있었다. 특히 노란색과 갈색을 비출 때 한 색깔을 읽더라도 전등 빛을 받는 방향에 따라 두 색깔이 자주 혼동되었다.  

* 광센서로 모터 제어하기 - 밝기 구분
![](https://github.com/hwa10209/IOT/blob/master/img/2_5.PNG)

> 색깔구분과 별개로 밝기 구분으로 모터의 회전속도를 조절해 보았다. 레벨이 높을수록 모터의 회전이 빨랐다.

* 초음파센서로 모터 제어하기

![](https://github.com/hwa10209/IOT/blob/master/img/2_6.PNG)

[동작 영상](https://youtu.be/scAPinIK-Bc)

> 초음파센서에 대한 교정을 수행하면서 5cm부터 25cm까지 총 5개의 단계를 지정해 주었다. 초음파 센서를 통해 측정한 거리가 멀어질수록 모터의 속도를 빠르게 해 주었고 5cm 보다 작거나 5cm에 가까운 값이 측정될 때 또는 너무 먼 거리가 측정될 때는 모터가 정지되도록 설정해주었다. 이렇게 모터가 정지되는 구간을 설정해 둔 이유는 5cm보다 가까운 거리를 측정해 보았을 때 5cm이하의 거리가 잘 표시되지 않았고 실제로 소리의 반사를 이용하는 센서의 특성상 3cm 미만의 거리를 측정했을 때 거리를 제대로 측정하지 못하고 수십~수백의 무작위 거리가 나왔기 때문이다. 그 결과 5~30cm 거리를 측정하는 동안 모터의 회전이 점점 빨라지는 모습을 확인할 수 있었다. 그런데 센싱의 주기가 30ms로 짧아서 그런지 광센서를 이용할때보다 깜빡임이 조금 더 심해졌다.

#### 고찰
>색깔을 센싱할 때 색깔을 다르게 인식하는 경우가 한번 씩 생기곤 했는데 calibration 과정에서 너무 많은 색깔을 입력해서 각 색깔에 해당하는 센서값들이 촘촘하게 저장된게 아닌가 싶다. 그래서 calibration을 하고 바로 인식을 시켰음에도 불구하고 노란색과 갈색같은 경우는 구분을 잘 못하는 것 같았다.  이렇게 비슷한 값들을 구분하기위해서 어떤 대안을 도입해야 할까 고민하다가 조교님이 지난 실습시간에 언급한 빛의 밝기와 색깔을 동시에 인식한다는 센서에 대해 생각이 났다. 색깔을 구분하는 방법에는 여러 요소가 들어가는데 일차원적인 값만 이용했기 때문에 센싱이 매끄럽지 않았나 하는 생각이 들었고, 한가지 대상의 구분을 위해 이차원 이상의 값을 이용하는 것이 물체 판별을 더 쉬워지게 한다는 것을 깨달았다.  그런데 하나의 광센서도 빛의 밝기, 색깔 구분처럼 두 개이상의 센싱을 할 수 있으니 calibration 과정에서 시간이 좀더 걸리더라도 밝기 인식을 한차례 완료 한 후 이어서 색깔을 인식하는 방법으로 효율을 높일 수 있지 않을 까 하는 생각도 들었지만, 그것을 막상 코드로 구현하려고 하니 그것역시 지금의 실력으로는 쉽지는 않았다. 그래서 결국 개인적으로 실험을 해 볼 때 는 빛의 밝기에 대해 한번, 색깔에 대해 한번 이렇게 따로 수행해볼 수밖에 없어서 아쉬웠다.  2차원, 3차원 배열을 이용하면 여러 값을 한 대상에 대응시킬 수 있을 까, 조금 뒤에 있을 경기에 도움이 되도록 좀 더 고민해 보아 야겠다.<br>색깔이나 거리를 센싱할 때 값이 오름차순으로 읽어지도록 센싱했음에도 불구하고 값이 툭툭 튀어서 모터의 속도가 급변하곤 했다.  단계를 여러개로 나누면 나눌수록 더 부드러운 가속과 감속이 가능할 것 같지만 또 그렇게 되면 위에서 겪었듯이 정확한 센싱이 어려워지는 문제가 발생할 것이다. 값이 연속적으로 들어오지 않고 급격하게 바뀐다면 무시한다거나 값을 다른 센서들과 통합한다든지 읽어오는 데이터 값을 처리하는 방법을 고민해 보아야겠다.

---
### 3. HW3 : 우선순위 스케쥴링
#### 개요
> 앞에서 했던 코드들을 task별로 나눠서 구현하고 우선순위를 갖고 동시에 실행해보면서 RTOS의 특징을 이해한다.

#### 다이어그램/구조
![](https://github.com/hwa10209/IOT/blob/master/img/3_1.PNG)

```
int usrmain(int argc, char * argv[])
```
> ESTK 의 작업을 실행, 디버깅을 시작할 때 가장 먼저 실행되는 함수이다. 모터와 디코더, 광센서(색 모드)를 활성화 하고 모터와 광센서가 구동될 각각 하나씩의 task를 생성한다. task를 생성하는 과정에서 void pointer를 이용하여 센서값의 저장과 모터의 	회전에 사용될 level값의 주소를 전달해준다. 또 우선순위에 구분을 두어 광센서에 좀 더 높은 순위를 주었다.

```
static void motortask(void * level)
```
> 모터 task의 동작에 쓰이는 함수. level 값에 비례하는 속도로 모터를 회전한다. 멈추지 않고 계속 회전하도록 설정되어있다. 그러나 우선순위가 센서의 작업보다 낮아서 센서의 작업이 시작될 때 잠시 대기상태가 된다.

```
static void ev3sensortask(void * level)
```
> 광센서를 통해 센싱한 값을 모터가 이용할 수 있게 level 에 저장한다, sleep  함수에 의해 50ms마다 한번씩 작동하는데 우선순위가 높아 50ms마다 한번의 작업이 보장된다.

#### 실행결과
![](https://github.com/hwa10209/IOT/blob/master/img/3_2.PNG)

> 지난실험에서 한것과 같이 입력받는 색깔에 따라 모터의 속도가 달라지도록 구현하였다. 그 과정에서 색상의 구분과 모터의 회전속도 변경을 별개의 task로 따로 구현하였다. 기존의 하나의 task에서 구현했던것과 코드의 순서에 따라 순차적으로 바뀌던 단일task 작업에서 벗어나서 여러개의 프로세스가  상대적으로 짧은시간동안 바꿔가면서 거의 동시에 동작하는 것처럼 보인다. 우선순위를 높게 지정한 광센서는 50ms마다 색을 입력받도록 하였는데 sleep 시간만 끝나면 낮은 우선순위의 task가 sleep없이 연속적으로 작업중이더라도 바로 끼어들 수 있었다. 그래서 그 값이 바로바로 모터의 회전 속도로 반영되었다.
<br>이어서 task_sleep 대신 bsp_busywaitms 함수를 사용하고, 서로 다른 우선순위를 갖는 부품을 이용하여  한 task만 지속적으로 수행하도록 함으로써 context switching이 일어나는 것을 의도적으로 막아보았다. 보통 한 동작이 끝났을 때 호출하는 sleep함수는 사용하던 cpu와 같은 자원을 반환하고 task를 대기상태로 보내는것에 반해 busy waitms 함수는 cpu를 반환하지 않고 작업이 끝났음에도 그 상태를 유지하게 한다. 따라서 다음과 같은 실험 결과들을 확인 할 수 있었다. 
<br>색을 인식한 직후에 busywaitms 5초의 정지시간을 지정해 줌으로써 cpu는 새로운 작업을 수행하지 못하고 기다리기만 할 수 있다. 따라서 5초동안 모터의 속도를 변경할수 없고 심지어 광센서로 색을 비추어도 입력이 되지않아 LCD에는 busywaitms이 호출되기 직전의 값만 표시되었다.
<br>게다가 모터와 광센서 두 task중 광센서의 우선순위를 높게 지정하였기 떄문에 busywaitms의 시간이 끝났음에도 불구하고 모터의 task는 실행되지않고 광센서의 task만 반복적으로 실행되었다. 따라서 모터의 속도가 변하지 않아 디버깅을 시작할 때의 멈춰있던 모터의 그 상태가 시간이 흘러도 유지되었다.

![](https://github.com/hwa10209/IOT/blob/master/img/3_3.PNG)

#### 고찰
> 이번 수업과 실험을 통해 한 개 이상의 task를 생성하고 다룰 수 있게 되면서 real time os의 특성을 충분히 이용할 수 있게 되었다. 기존의 방식대로는 하나의 task 만 이용한다면 어떤 작업을 할 때 코드가 수행되는 특성상 한번에 한가지일만, 정해진 순서대로 할 수 있었다. 따라서 그 작업사이 사이에 cpu의 작업수행속도와 비교해보면 매우 길다고 할 수 있은 대기시간에 의해 작업 효율이 떨어졌고 갑자기 들어오는 신호나 변하는 상황에 대응하기가 어려웠다. 하지만 이제 동시에 이루어져야할 작업을 각각 잘게 쪼개어서 유기적으로 수행할 수 있고 우선순위 스케쥴링의 도움을 받아 좀더 급한, 중요한 일을 우선적으로 처리할 수 있게 되었다. 이러한 특성은 위에서 수행한 간단한 실험에서도 확인할 수 있다. 단순하게 보면 모터의 속도를 바꾸고, 빛을 받아들이는 두가지 일 뿐이지만 그 두가지 일이 거의 동시에 일어나기 때문에 받아들인 색깔이 모터의 동작에 실시간으로 반영된다. 단순해 보이지만 모터가 광센서의 작업수행에 종속적이기 때문에 모터가 계속 일을 하다가도 광센서를 통해 어떤 값이 들어오면 바로 반영이 되어야 할 것이다. 따라서 두가지 일이 동시에 시작되려 할 때 광센서로 정보를 받아들이는 것이 좀더 중요하므로 광센서의 priority를 높게줘야 할 것이다. 만약 그렇지 않고 같은 우선순위를 가지고 작업을 수행하다보면 공평하게 round robin 방식으로 수행되는데 그렇게 되면 정작 빛 정보를 꼭 받아들여야 할 상황에서 정보를 놓치게 되고 즉각적인 반응을 하지 못해 만약 자율주행 자동차의 경우였다면 사고가 날 수도 있었을 것이다. 따라서 위의 실험에서도 모터가 계속 일을 하는 와중에 높은 우선순위를 가지는 센서가 끼어들어서 우선적으로 작업을 센싱을 수행할 수 있도록 구현해보았다.
<br>또 그 과정에서 Task를 만드는 것이 생각보다 섬세한 작업임을 집접 체험해보면서 깨달았다. Task를 늘린다는 것이 어떤 일을 하고 있는 와중에 특정한 작업을 추가로 수행하도록 환경을 조성해주는 것과 같아서 기본적으로 어떤 일을 할지 명시해주는 함수가 있어야 되고 서로 구분하기 위한 이름과 중요도에 따라 우선순위도 있어야한다. 또 함수를 따라 동작하기 위해 필요한 변수를 넘겨받을 필요가 있는데 위 실험에서 level 값을 서로 주고받는 용도로 void 포인터를 통해 주소를 넘겨줌으로써 전체적인 Task의 생성을 체험해 보았다. 그리고 아직 stackdepth 변수는 사용해 보지 못했지만 프로세스에서 자식 프로세스가 생길 때 각각의 stack공간이 생기는 것과 비슷하지 않을 까 하는 생각이 들었다.

---
### 4. HW4 : Semaphore
#### 세마포의 종류
* Binary semaphore(이진 세마포어)
> 여러개의 프로세스가 동작하면서 공유된 자원을 다룰 때 동시에 접근해서 작업한다면 작업한 값의 결과의 정확성이 보장되지 않을수도 있다. 따라서 그 자원의 한 데이터를 한 프로세스씩만 접근을 하도록 제한해 주는데 그 과정에서 단순히 P (lock)과 V (unlock), 즉 0과 1의 두 개의 값만을 통해서만 제한해 주는 것을 Binary semaphore라고 한다.

* Counting semaphore(계수 세마포어)
> 세마포어가 사용가능한 자원의 개수를 나타내는 변수로 사용되며 값의 범위가 정해져 있지 않다. 세마포어가 여러개로 존재하는 자원의 수와 같은 값으로 초기화 된 채로 시작하고 binary semaphore 의 lock 에 해당하는 P가 호출될 때 마다 semaphore가 1씩 줄어든다. 그리고 그 자원이 사용되고 있다고 표시해준다. 또 unlock에 해당하는 V가 호출될 때 마다 줄어들었던 숫자가 1씩 늘어나면서 프로세스가 자원을 반납한다. 그리고 그 자원이 사용가능하다고 표시해준다. 이러한 과정 때문에 이진 세마포어 보다 구현하기가 복잡하다.

* Mutex
> 가장 큰 차이점은 semaphore는 공유된 자원의 데이터를 여러 프로세스가 접근하지 못하도록 막는 역할을 하고 mutex는 쓰레드들의 동시 접근을 막는다. 따라서 둘이 적용되는 범위가 다른 것으로 볼 수 있는데 mutex 의 경우 부모 프로세스가 종료될 때 자동으로 삭제된다.	마찬가지로 범위가 더 큰 semaphore는 mutex를 포함하는 개념이기 때문에 semaphore는 mutex가 될 수 있지만 그 반대는 될 수 없다. 또한 counting semaphore처럼 semaphore는 동기화 대상이 하나 이상이 될 수 있는 반면에  mutex는 동기화 대상이 하나이다.

#### Priority inversion
> 우선순위가 더 높은 task가 실행가능 상태가 되었지만 우선순위가 더 낮은 task가 cpu를 점유하고 있어서 우선순위가 높음에도 불구하고 실행되지 못하고 있는 상태. <br>예를 들어 우선순위가 다른 세 개의 task가 있을 때 우선순위가 가장 낮은 task3이 먼저 semaphore를 얻었을 때 이 semaphore를 얻으려하는 task1은 우선순위가 높더라도 semaphore가 반환될 때 까지 기다려야한다. 이 와중에 중간단계 우선순위의 task2가 실행되어 버린다. 결과적으로 task2와 task1의 우선순위가 역전되어 수행됨. 이를 예방해 주어야 한다.

#### Priority inversion의 해결책
* 우선순위 상속(priority inheritance) 프로토콜
> 위의 똑같은 예시에서 task1이 task3의 semaphore 때문에 수행되지 못하고 있으므로 task3이 semaphore를 반환할 때 까지 우선순위를 임시로 task1만큼 높여서 먼저 실행될 수 있게 해준다. 그렇게 되면 중간 우선순위를 가지는 task2가 먼저 실행되는 경우를 막아준다. 물론 task3의 semaphore가 반환되면 우선순위는 원래대로 돌아간다. 다만 이 방법은 우선순위를 변경하는 과정에 의한 overhead 가 있을 수 있다.

* 우선순위 상한(priority ceiling) 프로토콜
> 공유되는 자원을 사용하는 프로세스의 우선순위를 모두 알고 있다는 가정 하에 사용되고 그 자원을 lock한 프로세스는 일시적으로 다른 프로세스들이 가지는 우선순위보다 더 높은 우선순위를 갖고 그 작업을 먼저 수행하게 된다.

---
### 5. HW5 : Timer를 이용한 Stopwatch 구현 
#### 개요
> 타이머 카운터와 스위치 인터럽트를 이용하여 시작, 일지정지, 리셋 기능이 있는 스톱워치를 만들어 본다.

#### 다이어그램/구조
![](https://github.com/hwa10209/IOT/blob/master/img/5_1.PNG)

```
int usrmain(int argc, char * argv[])
```
> ESTK 의 작업을 실행, 디버깅을 시작할 때 가장 먼저 실행되는 함수이다.<br>_g_sem 세마포와 print_lcd task를 생성한다. 또 타이머 인터럽트를 만들고 사용하기 위한 설정을 한다. 

```
static void timer_isr(void)
```
> 타이머 인터럽트가 발생할 때 마다 호출되는 함수. 특별한 일이 없다면 인터럽트가 1초마다 발생하므로 카운터를 1초마다 1씩 증가시킨다.

```
static void switch_isr(void)
```
> 스위치 1을 눌러 스위치 인터럽트가 발생할 때 마다 호출되는 함수. 최초 1회 호출 시 	타이머를 시작하도록 레지스터 값을 설정하고 누를 때 마다 타이머 인터럽트를 일시정지, 재시작하여 스톱워치 일시정지 기능을 구현함

```
static void switch_isr2(void)
```
> 스위치 2를 눌러 스위치 인터럽트가 발생할 때 마다 호출되는 함수. count 값을 0으로 바꿔주어 스톱워치 리셋 기능을 구현함 

#### 실행결과
![](https://github.com/hwa10209/IOT/blob/master/img/5_2.PNG)

![](https://github.com/hwa10209/IOT/blob/master/img/5_3.PNG)

> 디버그를 시작하고 1번스위치를 누르면 스톱워치가 시작되고 시간이 표시된다. 1초마다 타이머 인터럽트가 걸려서 표시되는 시간이 1씩 늘어나는 모습을 확인할 수 있다.
<br>시간이 어느정도 증가하였을 때 스위치 2를 누르면 시간이 reset되서 다시 1초부터 흐르기 시작한다. 또 시간이 흐르고 있을 때 스위치 1을 누르면 일서정지되고 한번 더 누르면 일시정지가 해제된다.

#### 고찰
> 프로세서의 클럭이 진행되면서 카운터레지스터의 값이 미리 지정된 수 32768까지 증가하고 32768이 되는 순간 타이머 인터럽트가 발생하여 count 값이 1 증가한다. 이 값을 task에서 lcd에 표시해준다. 또 스위치를 누르면 원하는 때에 스위치 인터럽트도 발생시켜서 전역변수인 count 값을 인위적으로 수정하거나 타이머 인터럽트가 일어나지 않게 설정할 수 있다. 타이머를 일시정지 할 때 에는 TC1->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKDIS; 코드를 이용하여 카운터가 증가하지 못하도록 하였고 TC1->TC_CHANNEL[0].TC_CCR = TC_CCR_CLKEN;를 통해 일시 정지 해제를 하려고 하였으나 정상적으로 동작하지 않아 TC1->TC_CHANNEL[0].TC_CCR = TC_CCR_SWTRG; 코드도 같이 추가해주었다. 그러자 의도하던 일시정지, 일시정지 해제기능이 구현되었다. 이를 통해 카운터를 재시작하면 타이머도 재시작하여야 함을 알 수 있다.
<br>일시정지/해제의 또 다른 방법으로 counter는 정상동작 하도록 두고 타이머의 인터럽트만 끄고 켤 수 있도록 intr_enable(TC3_IRQn); intr_disable(TC3_IRQn);을 이용하여 위 기능을 구현해 보았다. 의도한 대로 일시정지와 일시정지 해제는 잘 되지만 3번에 한번정도 일시정지 해제를 시도할 때 시간이 다시 흐르기 시작하면서 급격하게 2초가 흘러버리는 현상이 확인되었다. 이 현상의 원인으로는 이전의 타이머 인터럽트 함수가 실행되던 중간에 중지되었기 때문에 카운터의 값이 32768을 넘어도 초기화 되지 않고 증가하게 되고 타이머 인터럽트가 재개되는 순간 의도했던 32768보다 큰 수와 비교를 하게 되면서 오류가 발생하지 않았을까 추측해 보았다.<br>위에 기술된 일련의 과정은 모두 인터럽트가 발생하면서 일어난다. 따라서 타이머는 타이머대로 스위치는 스위치대로 즉각적으로 수행이 되는데,  이 과정을 polling 방식으로 구현할 수 도 있다. 하지만 그렇게 구현하게 되면 타이머 대신 delay를 사용하고 스위치가 눌렸는지 확인하기위해 스위치가 눌릴만한 순간을 예측해서 그 지점마다 스위치와 연결된 레지스터 값을 직접 확인해주는 코드가 있어야 할 것이다. 또 delay 1초에 의해 스위치가 무시되는 상황이 발생할 수 있으므로 2,3개의 task를 만들어 따로 구현하면 된다. 이렇게 하면 인터럽트를 통해 구현한 기능을 비슷하게 따라할 수 있게 된다. 하지만 여기서 만약 좀 더 많은 기능들이 추가되고 task의 할 일이 많아진다면 아무리 우선순위를 주더라도 task간의 작업이 차례를 기다려 수행되기 때문에 즉각적으로 반응하지 못해서 1초보다 큰 시간이 지나서 표시되는 시간이 1증가하거나 스위치를 눌러도 반응하지 않는 일이 발생할 수 있다.
  <br>추가로 일시정지된 상태에서는 reset을 해 주어도 시간이 초기화 되지 않다가 일시정지 해제를 누른 순간 reset된 시간이 표시되는데 이는 semaphore 때문인 것 같다.
