# COMP319001 알고리즘 / 2019년 2학기 / 장길진

알고리즘 과목을 수강하며 수행한 과제들 입니다.
<br>
codeblock 환경에서 구현하였고 C 언어를 이용하였습니다.

## 요약

> HW1<br>HW2<br>HW3<br>HW4<br>HW5 

## 수행내용
### 1. HW1

> input 파일을 입력으로 이용하여 binary seach를 수행하는 코드를 구현
---
### 2. HW2

>arraysort와 listsort를 구현하였고, sorting할 데이터가 많은 경우에서 동작하는 코드를 구현
<br>각각의 input 폴더 내에 있는 파일들을 sorting 후 output폴더에 저장한다
---
### 3. HW3

>binary search tree 코드를 구현
---
### 4. HW4

* 0-1 knapsack problem 
* 0-1 knapsack with one item split
* 0-1 knapsack with one duplicate item
* 0-1 knapsack with two identical knapsacks
> 위 4가지 경우에 해당하는 knapsack problem들을 해결하는 코드를 구현
<br>4번의 경우 3차원 배열을 이용하여 해결 함
---
### 5. HW5

#### 개요
* 제한된 경로의 길이로 최대한 많은 점 방문하기
> (100,100) 좌표를 가지는 평면위에 100개의 점(마을)과 움직일 수 있는 거리(연료)가 주어진다. 이 때, 최대한 많은 수의 점을 지날 수 있는 알고리즘을 구현

#### 알고리즘 구상
* template
> 파일 입출력을 통해 데이터가 입력되고, standard out으로 출력된다.
점의 개수와 그 개수에 해당하는 좌표들을 입력받고 차례대로 배열에 넣는다.
입력되는 순서대로 배열이 만들어지기 때문에 정렬이 필요하다.
따라서 그 배열을 100X100의 배열에 찍어보고 2중 loop를 통해 x,y를 차례로 증가시키면서 점들을 또 다른 배열에 순서대로 주워 담는다.
이렇게 하면 100개의 점들이 하나의 구조체 배열로 순서대로 들어가게 된다. 

* 모든 점을 지나보고 가장 많은 점을 지난 경우를 선택
>linked list를 이용하여 점을 하나씩 연결한다.
(0,0)에서 출발하여 (100,100)에 도착하기 까지 수많은 선택지가 존재한다.
한 칸 한 칸을 옮겨갈 때 마다 모든 선택할 수 있는 점을 다음 점으로 선택, 이동, 수많은 연결이 생길 것이고 (100,100)에 도착하기 까지 각각의 node에서 recursive로 실행된다.
다음에 있을 수 있는 수많은 node중 한정된 연료에 대해 가장 많은 경로를 가지는 node가  다음의 node로 최종적으로 연결 된다.

<br>ex) 현재 연료로 (95,95)출발, (100,100)에 도착하기 까지 최대 2개의 점 방문가능. 똑같이 (94,94)에서 (100,100)까지 3개의 점 방문가능. 
(93,93)에서 (95,95)또는 (94,94)을 경유하여 (100,100)까지 갈 연료가 있을 때, (93,93) node 에는  (94,94)가 연결된다. 

* 100개의 node들을 중간구간들을 나눠 연결을 따져보기
>모든 경우에 대해 연결을 시도해 보아야 하기 때문에 간단하게 계산해 보더라도 최악의 경우 (0,0)에서 갈 수 있는 node 99개, (0,0)에서 (1,1)경유 할 경우 (1,1)에서 갈 수 있는 node 98개, 이런 방식으로 모두 만들어 지는 연결이 N-practical 이라고 볼 수 있다. 또한 모든 연결들을 시도해 보면서 각각의 node의 순서가 꼬이지 않아야 하기 때문에 template에서 최종적으로 만들어진 배열의 node를 malloc을 이용하여 동적할당, 복사하여 만든 node를 이용하여 연결을 시도하게 된다.
 big O notation으로 시간 복잡도를 따져 본다면 N^100 으로 N이 커질수록 시관과 메모리가 기하급수적으로 많이 허비된다. 실제로도 위 알고리즘을 이용하면 시간이 한참 걸리고 결국 PC의 메모리 stack 공간이 가득 차 강제 종료 되었다. 따라서 최대한 그 연결과 계산들을 줄이기 위해 몇가지 해결책을 고안했다.
 <br><br>
 ** 각각의 100개의 node들 간의 거리를 미리 계산하여 하나의 표를 만들어 이용한다.
 ** 또한 100개의 node들 중 중간 최종 목적지 까지 중간의 중간목표들을 임의로 지정해 두고 시작점과 중간목표 까지만의 연결만을 구하고 이런 나누어진 연결들을 최종적으로 연결하는 방식을 고안했다.
> ex)(1번node->10번node),(10번 node->20번 node)...(90번 node->100번 node)
<br>최종적으로 이 연결들의 시작과 끝부분만 다시 연결한다. 임의로 경유하는 점을 연결하는 만큼 최대로 방문할 수 있는 점은 실제 모든 경우를 다 따져보는 것 보다는 몇 개 줄어 들 수 있다. 하지만 이렇게 함으로 써 절약되는 시간과 메모리는 획기적으로 증가한다.
<br>ex)위의 경우 10XN^10 으로, 
이 역시 작은 수는 아니지만 big O notation 이라 실제로는 이정도가 되지는 않는다.

* 중간 경유지와 사용될 연료를 예상하여 나누는 방법
> 100개의 점들을 몇 번 나누어 경로를 각각 구해 연결할지 지정하는 함수를 만들었다.100개의 점들을 몇 번 나누어 경로를 각각 구해 연결할지 지정하는 함수를 만들었다.

> ex) 4부분으로 나누어 25개씩 경로를 따져보고 싶다면, 3개의 중간지점을 추가하게 되고, sorting 된 배열의 0,24,49,74,99의 index에 해당하는 node가 중간 경유지가 된다.

> 중간 경유지, 즉 중간 출발지점과 중간 목표지점들을 임의로 지정해 주는데, 이 점은 실제로 모든 점을 다 따져서 연결했을 경우에는 지나지 않았을 점일 수도 있고, 오히려 먼 거리를 돌아가는 점이 될 수도 있다. 따라서 중간 경유지를 선택할 때에 최대한 Y = 1X+0 직선과 가까운 점들(x좌표와 y좌표의 차가 가장 작은 점들)을 선택하면 그 위험을 줄이는 것이라고 판단했다. 이 점을 찾기 위해서 추가되는 중간지점 앞 뒤 몇 칸의 여유를 두고 움직여 보면서 최대한 x좌표와 y좌표의 차가 작은 지점을 찾는다. 

> ex) 0, 22, 53, 77, 99의 index의 node가 경유지가 최종적으로 선택됨

> 선택되는 중간 경유지들이 배열의 몇 번째 index인지 고려하여 그에 비례하는 연료를 분배해준다.

> ex) 0.22, 0.31, 0.24, 0.22

#### 알고리즘 구현

> hw5.c 참고

#### 결과
* Case 1

![](https://github.com/hwa10209/Algorithm/blob/master/img/5_1.bmp)
![](https://github.com/hwa10209/Algorithm/blob/master/img/5_2.bmp)
![](https://github.com/hwa10209/Algorithm/blob/master/img/5_3.bmp)

* Case 2

![](https://github.com/hwa10209/Algorithm/blob/master/img/5_4.bmp)
![](https://github.com/hwa10209/Algorithm/blob/master/img/5_5.bmp)
![](https://github.com/hwa10209/Algorithm/blob/master/img/5_6.bmp)

* Case 3

![](https://github.com/hwa10209/Algorithm/blob/master/img/5_7.bmp)
![](https://github.com/hwa10209/Algorithm/blob/master/img/5_8.bmp)

